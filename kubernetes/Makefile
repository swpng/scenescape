# SPDX-FileCopyrightText: (C) 2023 - 2025 Intel Corporation
# SPDX-License-Identifier: Apache-2.0

MANAGERIMAGE=scenescape-manager
CAMCALIBIMAGE=scenescape-camcalibration
CONTROLLERIMAGE=scenescape-controller
CLUSTERANALYTICSIMAGE=scenescape-cluster-analytics
MAPPINGIMAGE=scenescape-mapping

# Image groupings for flexible builds
CORE_IMAGES=$(MANAGERIMAGE) $(CAMCALIBIMAGE) $(CONTROLLERIMAGE)
EXPERIMENTAL_IMAGES=$(CLUSTERANALYTICSIMAGE) $(MAPPINGIMAGE)
ALL_IMAGES=$(CORE_IMAGES) $(EXPERIMENTAL_IMAGES)

VERSION:=$(shell cat ../version.txt)
NAMESPACE=scenescape
WORKINGDIR=$(shell dirname $(shell pwd))
ORGANIZATION?=intel
VALIDATION=
VALIDATION_FLAG=
DEPLOYMENT_TEST=
TEST_FLAGS=
# it may need to be increased if all models are being downloaded (see values.yaml)
INSTALL_TIMEOUT?=600s

ifeq ($(VALIDATION), 1)
    VALIDATION_FLAG=--set tests.enabled=true
endif

ifeq ($(DEPLOYMENT_TEST), 1)
    TEST_FLAGS=--wait --timeout $(INSTALL_TIMEOUT) --debug
endif

KINDREG=kind-registry
KINDREGPORT=5001
# Uncomment and set HOSTDIR if you want to access the persistent volumes on the host (root ownership)
# HOSTDIR=$(WORKINGDIR)/kind-storage

CERTPASS=$(shell openssl rand -base64 33)
REGISTRY=localhost:$(KINDREGPORT)

RELEASE=scenescape-release-1
FORCE_VAAPI?=0
CHART_DEBUG?=0

# Demo mode variable for Kubernetes deployments (core or all)
DEMO_K8S_MODE?=core

# Proxy settings: if http_proxy, https_proxy, or no_proxy environment variables are set,
# they will be automatically passed to the Helm chart during installation
# Chart debug: set CHART_DEBUG=1 to enable chartdebug=true in Helm deployment

# start kind, then install SceneScape with helm
default: install-deps clean-kind kind build-demo install

# Helper target to select build based on DEMO_K8S_MODE
.PHONY: build-demo
build-demo:
	@if [ "$(DEMO_K8S_MODE)" = "all" ]; then \
		$(MAKE) build-all; \
	else \
		$(MAKE) build-core; \
	fi

# publish to ITEP by building, packaging, then pushing
build-and-package: build-core package

# build scenescape images and push everything to a registry, then generate Chart.yaml
build: build-core

build-core: docker-build-core push-core

build-all: build-core build-experimental

build-experimental: docker-build-experimental push-experimental

kind: generate-kind-yaml start-kind install-cert-manager

# remove everything Kubernetes related from your machine
clean-all: clean-kind clean-kind-registry

# dependency installation (requires sudo) for kind, kubectl, k9s (optional), helm
# NO SUDO: alternatively, if your user does not have sudo access:
# 1. comment out the sudo commands for kind, kubectl, k9s and helm
# 2. move the kind, kubectl, k9s and helm binaries to your PATH manually from /tmp, e.g. to ~/.local/bin, like so:
# mv /tmp/kind /tmp/kubectl /tmp/k9s /tmp/helm ~/.local/bin
install-deps:
	@if [ -z "$(shell which kind)" ] ; then \
	    curl -Lo /tmp/kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64 ; \
	    chmod +x /tmp/kind ; \
	    sudo mv /tmp/kind /usr/local/bin/kind ; \
	    echo "kind installed" ; \
	fi
	@if [ -z "$(shell which kubectl)" ] ; then \
	    curl -Lo /tmp/kubectl https://dl.k8s.io/release/v1.28.1/bin/linux/amd64/kubectl ; \
	    chmod +x /tmp/kubectl ; \
	    sudo install -o root -g root -m 0755 /tmp/kubectl /usr/local/bin/kubectl ; \
	    echo "kubectl installed" ; \
	fi
	@if [ -z "$(shell which k9s)" ] ; then \
	    wget https://github.com/derailed/k9s/releases/download/v0.27.4/k9s_Linux_amd64.tar.gz -P /tmp ; \
	    tar -C /tmp -zxvf /tmp/k9s_Linux_amd64.tar.gz k9s ; \
	    sudo mv /tmp/k9s /usr/local/bin/k9s ; \
	    echo "k9s installed" ; \
	fi
	@if [ -z "$(shell which helm)" ] ; then \
	    wget https://get.helm.sh/helm-v3.13.0-linux-amd64.tar.gz -P /tmp ; \
	    tar -C /tmp -zxvf /tmp/helm-v3.13.0-linux-amd64.tar.gz --strip-components=1 linux-amd64/helm ; \
	    sudo mv /tmp/helm /usr/local/bin/helm ; \
	    echo "helm installed" ; \
	fi

# generate yaml for kind setup
generate-kind-yaml:
	mkdir -p setup
	sed -e "s|{KINDREGPORT}|$(KINDREGPORT)|g" template/kind.template > setup/kind.yaml
	sed -e "s|{KINDREG}|$(KINDREG)|g" -e "s|{KINDREGPORT}|$(KINDREGPORT)|g" \
	template/kind-config.template > setup/kind-config.yaml
	@if [ -z "$(HOSTDIR)" ] ; then \
	    sed -n -i '/{HOSTDIR}/q;p' setup/kind-config.yaml; \
	else \
	    sed -e "s|{HOSTDIR}|$(HOSTDIR)|g" -i setup/kind-config.yaml; \
	    echo "HOSTDIR is set. Kind will mount $(HOSTDIR) into container for persistent volumes."; \
	fi

# run a test cluster in a kind container. Requires the kind binary
start-kind:
	if [ "$(shell docker inspect -f '{{.State.Running}}' "$(KINDREG)" 2>/dev/null || true)" != 'true' ]; then \
	    docker run -d --restart=always -p "127.0.0.1:$(KINDREGPORT):5000" --name "$(KINDREG)" registry:2; \
	fi
	NO_PROXY=$(NO_PROXY),$(KINDREG) kind create cluster --config ./setup/kind-config.yaml || true
	docker network connect "kind" "$(KINDREG)" || true
	kubectl apply -f ./setup/kind.yaml
	@until kubectl get svc kubernetes -o go-template='{{.spec.clusterIP}}' | grep -qv '<none>'; do \
	    sleep 1; \
	done
	kubectl patch service kubernetes --type=merge -p '{"spec": {"ports": [{"name": "https", "port": 6443, "targetPort": 6443}]}}'
	kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml
	@until kubectl get pod -n ingress-nginx --selector=app.kubernetes.io/component=controller -o go-template='{{.items | len}}' | grep -qxF 1; do \
	    sleep 1; \
	done
# kubectl -n ingress-nginx patch deployment ingress-nginx-controller --type=json -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--enable-ssl-passthrough"}]'
	kubectl wait -n ingress-nginx --for=condition=ready pod --selector=app.kubernetes.io/component=controller --timeout=300s

# remove the kind container
clean-kind:
	kind delete cluster
	docker network disconnect kind $(KINDREG) || true
	docker network rm kind || true

# remove the kind registry and its volume
clean-kind-registry:
	docker stop $(KINDREG) || true
	docker rm --volumes $(KINDREG) || true

install-cert-manager:
	kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.18.2/cert-manager.yaml

# build scenescape docker images, download models for init-models
# note, will make unneeded secrets in secrets/ as well
docker-build-core:
	make -C .. CERTPASS=$(CERTPASS) FORCE_VAAPI=$(FORCE_VAAPI)

docker-build-experimental:
	make -C .. build-experimental CERTPASS=$(CERTPASS) FORCE_VAAPI=$(FORCE_VAAPI)

push-core:
	docker tag $(MANAGERIMAGE):$(VERSION) $(REGISTRY)/$(ORGANIZATION)/$(MANAGERIMAGE):$(VERSION)
	docker push $(REGISTRY)/$(ORGANIZATION)/$(MANAGERIMAGE):$(VERSION)
	docker tag $(CAMCALIBIMAGE):$(VERSION) $(REGISTRY)/$(ORGANIZATION)/$(CAMCALIBIMAGE):$(VERSION)
	docker push $(REGISTRY)/$(ORGANIZATION)/$(CAMCALIBIMAGE):$(VERSION)
	docker tag $(CONTROLLERIMAGE):$(VERSION) $(REGISTRY)/$(ORGANIZATION)/$(CONTROLLERIMAGE):$(VERSION)
	docker push $(REGISTRY)/$(ORGANIZATION)/$(CONTROLLERIMAGE):$(VERSION)

push-experimental:
	# optional images for cluster analytics and mapping components
	docker tag $(CLUSTERANALYTICSIMAGE):$(VERSION) $(REGISTRY)/$(ORGANIZATION)/$(CLUSTERANALYTICSIMAGE):$(VERSION)
	docker push $(REGISTRY)/$(ORGANIZATION)/$(CLUSTERANALYTICSIMAGE):$(VERSION)
	docker tag $(MAPPINGIMAGE):$(VERSION) $(REGISTRY)/$(ORGANIZATION)/$(MAPPINGIMAGE):$(VERSION)
	docker push $(REGISTRY)/$(ORGANIZATION)/$(MAPPINGIMAGE):$(VERSION)

push-all: push-core push-experimental

# generate Chart.yaml with appropriate version.txt
chart.yaml:
	sed -e "s|{VERSION}|$(VERSION)|g" template/Chart.template > scenescape-chart/Chart.yaml

# packages and pushes the helm chart
package: copy-files chart.yaml
	helm package scenescape-chart/

# Query what's in the registry (local)
list-registry:
	curl -X GET http://$(REGISTRY)/v2/_catalog

copy-files:
	mkdir -p scenescape-chart/files/dlsps
	mkdir -p scenescape-chart/files/broker
	mkdir -p scenescape-chart/files/model-installer
	mkdir -p scenescape-chart/files/sample-data
	cp -r ../dlstreamer-pipeline-server/user_scripts/gvapython/sscape/* scenescape-chart/files/dlsps/
	cp ../dlstreamer-pipeline-server/mosquitto/mosquitto-secure.conf scenescape-chart/files/broker/mosquitto-secure.conf
	cp -r ../model_installer/src/* scenescape-chart/files/model-installer/
	cp ../model_installer/requirements-runtime.txt scenescape-chart/files/model-installer/requirements-runtime.txt
	cp ../dlstreamer-pipeline-server/model-proc-files/person-detection-retail-0013.json scenescape-chart/files/model-installer/person-detection-retail-0013.json
	cp ../dlstreamer-pipeline-server/model_config.json scenescape-chart/files/model-installer/model_config.json
	cp ../controller/config/tracker-config.json scenescape-chart/files/model-installer/tracker-config.json
	cp ../sample_data/download-sample-data-k8s.sh scenescape-chart/files/sample-data/download-sample-data-k8s.sh
	cp ../sample_data/convert-videos-k8s.sh scenescape-chart/files/sample-data/convert-videos-k8s.sh


# to test template rendering
# helm template -s templates/ingress.yaml kubernetes/scenescape-chart/
# helm install scenescape-release-1 kubernetes/scenescape-chart/ --dry-run --debug
install: copy-files
	@VALUES_FILE=""; \
	if [ -n "$(http_proxy)" ] || [ -n "$(https_proxy)" ]; then \
		VALUES_FILE="/tmp/scenescape-proxy-values.yaml"; \
		if [ -n "$(http_proxy)" ]; then \
			echo "httpProxy: \"$(http_proxy)\"" >> $$VALUES_FILE; \
		fi; \
		if [ -n "$(https_proxy)" ]; then \
			echo "httpsProxy: \"$(https_proxy)\"" >> $$VALUES_FILE; \
		fi; \
		if [ -n "$(no_proxy)" ]; then \
			echo "noProxy: \"$(no_proxy)\"" >> $$VALUES_FILE; \
		fi; \
		VALUES_FILE="-f $$VALUES_FILE"; \
	fi; \
	DEBUG_ARGS=""; \
	if [ "$(CHART_DEBUG)" = "1" ]; then \
		DEBUG_ARGS="--set chartdebug=true"; \
	fi; \
	SUPASS_ARG=""; \
	if [ -n "$${SUPASS}" ]; then \
		SUPASS_ARG="--set supass=$${SUPASS}"; \
	fi; \
	PGPASS_ARG=""; \
	if [ -n "$${PGPASS}" ]; then \
		PGPASS_ARG="--set pgserver.password=$${PGPASS}"; \
	fi; \
	MODE_ARG=""; \
	if [ "$(DEMO_K8S_MODE)" = "all" ]; then \
		MODE_ARG="--set mapping.enabled=true --set clusterAnalytics.enabled=true"; \
	fi; \
	REPOSITORY_ARG="--set repository=$(REGISTRY)"; \
	helm upgrade $(RELEASE) --install scenescape-chart/ -n $(NAMESPACE) --create-namespace --timeout $(INSTALL_TIMEOUT) $${DEBUG_ARGS} $${REPOSITORY_ARG} $${SUPASS_ARG} $${PGPASS_ARG} $${MODE_ARG} $${VALUES_FILE} $(VALIDATION_FLAG) $(TEST_FLAGS);
	@if [ -f "/tmp/scenescape-proxy-values.yaml" ]; then \
		rm -f /tmp/scenescape-proxy-values.yaml; \
	fi

uninstall:
	helm uninstall $(RELEASE) -n $(NAMESPACE) || true

delete-namespace:
	kubectl delete ns $(NAMESPACE) || true

# development targets
# wait for scenescape to be ready
wait-for-ready:
	@until kubectl get pod -n $(NAMESPACE) --selector="app=$(RELEASE)-scene" -o go-template='{{.items | len}}' | grep -qxF 1; do \
	    sleep 1; \
	done
	kubectl wait -n $(NAMESPACE) --for=condition=ready pod --selector="app=$(RELEASE)-scene" --timeout=240s

# below targets work if registry and kind are already running
# building and reinstalling (during development)
rebuild: rebuild-demo

rebuild-demo:
	@if [ "$(DEMO_K8S_MODE)" = "all" ]; then \
		$(MAKE) rebuild-all; \
	else \
		$(MAKE) rebuild-core; \
	fi

rebuild-core: uninstall delete-namespace build-core install

rebuild-all: uninstall delete-namespace build-all install

build-validation: build-validation-demo

build-validation-demo:
	@if [ "$(DEMO_K8S_MODE)" = "all" ]; then \
		$(MAKE) build-validation-all; \
	else \
		$(MAKE) build-validation-core; \
	fi

build-validation-core: delete-namespace build-core install wait-for-ready

build-validation-all: delete-namespace build-all install wait-for-ready
