#!/bin/bash

# SPDX-FileCopyrightText: (C) 2023 - 2025 Intel Corporation
# SPDX-License-Identifier: Apache-2.0

set -e

# Configuration variables
scenescape_image=scenescape-manager:1.4.0
pg_new_version="17.6"
dbdir=db
secretsdir=./manager/secrets
check_only=0
appdir=/workspace
backup_dir="${PWD}/scenescape_vol-backup"

# Utility Functions
run_table_rename() {
  local SECRETS_SRC="secrets"
  local SECRETS_DEST="manager/secrets"
  local CONTAINER_NAME="pg_backup"
  local IMAGE_NAME="scenescape"
  local WORKDIR="/workspace"
  local WAITFORDB=40

  echo "Copying secrets to $SECRETS_DEST..."
  mkdir -p "$SECRETS_DEST"
  cp "$SECRETS_SRC/browser.auth" "$SECRETS_DEST"
  cp "$SECRETS_SRC/calibration.auth" "$SECRETS_DEST"
  cp "$SECRETS_SRC/controller.auth" "$SECRETS_DEST"

  echo "Cleaning up existing containers..."
  docker rm -f $CONTAINER_NAME pg_migration 2>/dev/null || true

  echo "Starting $CONTAINER_NAME container..."
  docker run --rm --name $CONTAINER_NAME \
    --workdir $WORKDIR \
    -v "$(pwd)":$WORKDIR \
    -v "$(pwd)/migrations":$WORKDIR/migrations \
    -v "$(pwd)/db":$WORKDIR/db \
    --privileged \
    -e PYTHONPATH=$WORKDIR \
    -e SUPASS \
    --add-host pgserver:127.0.0.1 \
    -d $IMAGE_NAME database

  echo "Waiting $WAITFORDB seconds for DB to initialize..."
  sleep $WAITFORDB

  docker exec -it $CONTAINER_NAME bash -c "bash manager/tools/migrate-rename-manager"

  echo "Stopping container..."
  docker stop $CONTAINER_NAME
}

log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

check_error() {
    local exit_code=$?
    local error_message="$1"
    if [[ $exit_code -ne 0 ]]; then
        log_message "ERROR: $error_message (exit code: $exit_code)"
        exit $exit_code
    fi
}

wait_for_container() {
    local containername=$1
    local waitforstring=${2:-"Container is ready"}
    local max_wait=30
    local cur_wait=0
    local container_ready=0
    
    log_message "Waiting for container '${containername}' to start..."
    
    # Wait for container to exist
    while [ -z "$(docker ps -q -f name=${containername})" ]; do
        sleep 2
        ((cur_wait+=2))
        if [[ $cur_wait -ge $max_wait ]]; then
            log_message "ERROR: Container '${containername}' failed to start within ${max_wait} seconds"
            return 1
        fi
        
        # Show progress
        if (( cur_wait % 10 == 0 )); then
            log_message "Still waiting for container to start... (${cur_wait}s)"
        fi
    done
    
    log_message "Container '${containername}' is running, waiting for readiness signal..."
    
    # Reset counter for next phase
    cur_wait=0
    
    # Wait for container to be ready
    while true; do
        if docker logs ${containername} 2>&1 | grep -q "${waitforstring}"; then
            log_message "Container '${containername}' is ready!"
            return 0
        fi
        
        sleep 2
        ((cur_wait+=2))
        
        # Show progress periodically
        if (( cur_wait % 10 == 0 )); then
            log_message "Waiting for container readiness... (${cur_wait}s)"
            # Show last few lines of logs to help with debugging
            log_message "Recent container logs:"
            docker logs --tail 5 ${containername} 2>&1 | while read line; do
                log_message "  | $line"
            done
        fi
        
        if [[ $cur_wait -ge $max_wait ]]; then
            log_message "WARNING: Failed to detect readiness string '${waitforstring}' in container logs"
            log_message "Container may still be functional. Continuing..."
            return 1
        fi
    done
}

# Core functionality functions
check_prerequisites() {
    # Check if database directories exist
    if ! docker volume inspect scenescape_vol-db-backup >/dev/null 2>&1 || \
       ! docker volume inspect scenescape_vol-migrations-backup >/dev/null 2>&1; then
        log_message "Backup Docker volumes for database or migrations not found."
        log_message "No previous database installation detected. No upgrade or migration needed."
        exit 0
    fi

    # Get PostgreSQL versions
    pg_db_version=$(docker run --rm \
    -v scenescape_vol-db-backup:/var/lib/postgresql/data \
    alpine:latest \
    sh -c "cat /var/lib/postgresql/data/PG_VERSION")

    if [ -z "${pg_new_version}" ]; then
        log_message "Unknown Postgres version"
        exit 1
    fi
    
    log_message "Current PostgreSQL version: ${pg_db_version}"
    log_message "Target PostgreSQL version: ${pg_new_version}"
}

check_migration_needed() {
    local pg_container="pg_check"
    local db_container="pgserver"

    log_message "Running database migration..."
    if ! docker network inspect scenescape_migration >/dev/null 2>&1; then
        docker network create scenescape_migration
    fi

    if [ "$(printf '%s\n' "$pg_db_version" "$pg_new_version" | sort -V | head -n1)" = "$pg_new_version" ]; then
        log_message "Postgres server version ${pg_new_version} is not newer than existing database version ${pg_db_version}"

        # Check if migration is needed for the same version
        docker run -d \
        --name ${db_container} \
        -e POSTGRES_USER=scenescape \
        -e POSTGRES_PASSWORD=${dbpass} \
        -e POSTGRES_DB=scenescape \
        -v scenescape_vol-db-backup:/var/lib/postgresql/data \
        postgres:${pg_new_version}

        wait_for_container ${db_container} "database system is ready to accept connections"

        docker run -d \
            --name ${pg_container} \
            --network scenescape_migration \
            --workdir ${appdir} \
            -v ${PWD}:${appdir} \
            -v ${secretsdir}/django:/run/secrets/django \
            -v ${secretsdir}/browser.auth:/run/secrets/browser.auth \
            -v ${secretsdir}/calibration.auth:/run/secrets/calibration.auth \
            -v ${secretsdir}/controller.auth:/run/secrets/controller.auth \
            -v ${secretsdir}/certs:/run/secrets/certs \
            -v ${secretsdir}/ca:/run/secrets/ca \
            -v scenescape_vol-migrations:/workspace/migrations \
            --privileged \
            -e PYTHONPATH=${appdir} \
            scenescape-manager:latest \
            webserver \
            --dbhost ${db_container} \
            --dbtype postgres \
            --dbport 5432 \
        
        wait_for_container ${pg_container}
        
        if ! docker exec -it ${pg_container} /bin/bash manager/tools/migration --check; then
            log_message "No migration needed"
            docker stop ${pg_container}
            docker rm ${pg_container}
            exit 0
        fi

        docker stop ${pg_container}
        docker rm ${pg_container}
        docker stop ${db_container}
        docker rm ${db_container}
        docker network rm scenescape_migration
    fi
    
    if [ ${check_only} = 1 ]; then
        log_message "Migration check complete. Migration is needed."
        exit 0
    fi
}

backup_database() {
    local pg_container="pg_backup"
    local pg_uid=$(id -u)

    # Check backup exists
    if [ ! -d "${backup_dir}" ]; then
        echo "Backup directory ${backup_dir} does not exist!"
        return 1
    fi

    # adjust pg_hba.conf inside the volume
    log_message "Temporarily configuring pg_hba.conf in the database volume for backup..."
    docker run --rm \
        -v scenescape_vol-db-backup:/var/lib/postgresql/data \
        alpine sh -c "\
            cp /var/lib/postgresql/data/pg_hba.conf /var/lib/postgresql/data/pg_hba.conf-orig && \
            echo 'local all all trust' > /var/lib/postgresql/data/pg_hba.conf && \
            echo 'host all all 0.0.0.0/0 trust' >> /var/lib/postgresql/data/pg_hba.conf"

    # Start a temporary PostgreSQL container to create SQL dump
    log_message "Creating SQL backup from database volume..."
    docker run \
        --name ${pg_container} \
        -e POSTGRES_PASSWORD="${dbpass}" \
        -e POSTGRES_USER=scenescape \
        -e POSTGRES_HOST_AUTH_METHOD=trust \
        -v scenescape_vol-db-backup:/var/lib/postgresql/data \
        --entrypoint="/bin/bash" \
        -d \
        postgres:${pg_db_version} \
        -c "usermod --uid=${pg_uid} postgres ; id postgres ; exec docker-entrypoint.sh postgres"

    wait_for_container ${pg_container} "database system is ready to accept connections"

    log_message "Creating SQL backup of database..."
    docker exec ${pg_container} /bin/bash -c 'su postgres -c "pg_dump -U scenescape"' > ${backup_dir}/scenescape_db_backup_${now}.psql

    # Stop and remove temporary PostgreSQL container
    docker stop ${pg_container} && docker rm ${pg_container}
    log_message "SQL backup created at: ${backup_dir}/scenescape_db_backup_${now}.psql"
    log_message "Backup process completed successfully."
}

initialize_volumes() {
    local temp_container="init_volumes"
    
    log_message "Preparing Docker volumes..."
    docker volume rm scenescape_vol-db scenescape_vol-migrations 2>/dev/null || true
    docker volume create scenescape_vol-db
    docker volume create scenescape_vol-migrations
    docker volume create scenescape_vol-media
    
    # Copy migrations to volume
    log_message "Initializing migrations volume..."
    docker run --name ${temp_container} \
        -d \
        -v scenescape_vol-migrations-backup:/source/migrations \
        -v scenescape_vol-media-backup:/source/media \
        -v scenescape_vol-migrations:/dest/migrations \
        -v scenescape_vol-media:/dest/media \
        alpine:latest sleep 10
    
    docker exec ${temp_container} /bin/sh -c "cp -r /source/migrations/* /dest/migrations/"
    docker exec ${temp_container} /bin/sh -c "cp -r /source/media/* /dest/media/"
    docker stop ${temp_container} && docker rm ${temp_container}
}

upgrade_database() {
    local pg_container="pg_upgrade"

    log_message "Starting PostgreSQL ${pg_new_version} container..."
    docker run \
        --name ${pg_container} \
        -e POSTGRES_PASSWORD="${dbpass}" \
        -e POSTGRES_USER=scenescape \
        -e POSTGRES_HOST_AUTH_METHOD=trust \
        -e LANG=C.UTF-8 \
        -v scenescape_vol-db:/var/lib/postgresql/data \
        -d \
        postgres:${pg_new_version}
    
    wait_for_container ${pg_container} "database system is ready to accept connections"
    
    log_message "Restoring database from backup..."
    docker cp ${backup_dir}/scenescape_db_backup_${now}.psql ${pg_container}:/tmp/backup.psql
    docker exec ${pg_container} /bin/bash -c \
        "su postgres -c 'psql -U scenescape -d scenescape < /tmp/backup.psql'"
    
    log_message "Stopping and removing upgrade container..."
    docker stop ${pg_container}
    docker rm ${pg_container}
}

run_migration() {
    local pg_container="pg_migration"
    local db_container="pgserver"

    log_message "Running database migration..."
    if ! docker network inspect scenescape_migration >/dev/null 2>&1; then
        docker network create scenescape_migration
    fi

    docker run -d \
        --name ${db_container} \
        --network scenescape_migration \
        -e POSTGRES_USER=scenescape \
        -e POSTGRES_PASSWORD=${dbpass} \
        -e POSTGRES_DB=scenescape \
        -v scenescape_vol-db:/var/lib/postgresql/data \
        postgres:${pg_new_version}

    wait_for_container ${db_container} "database system is ready to accept connections"

    docker run -d \
        --name ${pg_container} \
        --network scenescape_migration \
        --workdir ${appdir} \
        -v ${PWD}:${appdir} \
        -v ${secretsdir}/django:/run/secrets/django \
        -v ${secretsdir}/browser.auth:/run/secrets/browser.auth \
        -v ${secretsdir}/calibration.auth:/run/secrets/calibration.auth \
        -v ${secretsdir}/controller.auth:/run/secrets/controller.auth \
        -v ${secretsdir}/certs:/run/secrets/certs \
        -v ${secretsdir}/ca:/run/secrets/ca \
        -v scenescape_vol-migrations:/workspace/migrations \
        --privileged \
        -e PYTHONPATH=${appdir} \
        scenescape-manager:latest \
        webserver \
        --dbhost ${db_container} \
        --dbtype postgres \
        --dbport 5432 \
        --overwrite-user-auth \

    # Check if container is ready
    if ! wait_for_container ${pg_container}; then
        log_message "ABORTING: Container failed to initialize properly"
        log_message "Automatic upgrade of database failed"
        docker stop ${pg_container} 2>/dev/null || true
        docker rm ${pg_container} 2>/dev/null || true
        return 1
    fi
    
    # Execute migration
    docker exec -it ${pg_container} /bin/bash manager/tools/migration
    local migration_status=$?
    
    log_message "Stopping and removing migration container..."
    docker stop ${pg_container}
    docker rm ${pg_container}
    docker stop ${db_container}
    docker rm ${db_container}
    docker network rm scenescape_migration

    if [[ $migration_status -ne 0 ]]; then
        log_message "Migration failed with status ${migration_status}"
        return $migration_status
    fi

    return 0
}

# Main script execution
main() {

    # Restore the database volume from tar backup
    DB_TAR="$(pwd)/scenescape_vol-backup/db-backup.tar.gz"
    echo "==> Restoring database volume 'scenescape_vol-db'..."

    if [ -f "$DB_TAR" ]; then
        docker volume create scenescape_vol-db-backup >/dev/null
        docker run --rm \
            -v scenescape_vol-db-backup:/volume \
            -v "$(pwd)/scenescape_vol-backup":/backup \
            alpine sh -c "cd /volume && tar xzf /backup/db-backup.tar.gz"
        echo "Database volume restored."
    else
        echo "Skipping restore: $DB_TAR not found."
    fi


    # Restore migrations volume
    MIG_TAR="$(pwd)/scenescape_vol-backup/migrations-backup.tar.gz"
    echo "==> Restoring migrations volume 'scenescape_vol-migrations'..."

    if [ -f "$MIG_TAR" ]; then
        docker volume create scenescape_vol-migrations-backup >/dev/null
        docker run --rm \
            -v scenescape_vol-migrations-backup:/volume \
            -v "$(pwd)/scenescape_vol-backup":/backup \
            alpine sh -c "cd /volume && tar xzf /backup/migrations-backup.tar.gz"
        echo "Migrations volume restored."
    else
        echo "Skipping restore: $MIG_TAR not found."
    fi

    # Restore media volume
    MEDIA_TAR="$(pwd)/scenescape_vol-backup/media-backup.tar.gz"
    echo "==> Restoring media volume 'scenescape_vol-media'..."

    if [ -f "$MEDIA_TAR" ]; then
        docker volume create scenescape_vol-media-backup >/dev/null
        docker run --rm \
            -v scenescape_vol-media-backup:/volume \
            -v "$(pwd)/scenescape_vol-backup":/backup \
            alpine sh -c "cd /volume && tar xzf /backup/media-backup.tar.gz"
        echo "Media volume restored."
    else
        echo "Skipping restore: $MEDIA_TAR not found."
    fi

    if docker run --rm -v scenescape_vol-migrations-backup:/migrations alpine \
        sh -c "grep -q 'sscape' /migrations/0001_initial.py"; then
        echo "/migrations/0001_initial.py exists and contains 'sscape'. Renaming tables and sscape references in migration file..."
        run_table_rename

    else
        echo "No 'sscape' reference found in /migrations/0001_initial.py, continuing upgrade..."
    fi

    # Parse command line arguments
    while [ $# -gt 0 ] && [[ "${1}" == --* ]]; do
        case "$1" in
            --check)
                check_only=1
                ;;
            *)
                log_message "Unknown option: $1"
                exit 1
                ;;
        esac
        shift
    done
    
    now=$(date +"%y%m%d-%H%M%S")
    
    # Step 1: Check if prerequisites are met
    check_prerequisites
    
    # Step 2: Check if migration is needed
    check_migration_needed
    
    # Step 3: Get database password
    dbpass=$(sed -r -n -e "/DATABASE_PASSWORD=/s/.*'([^']+)'/\1/p" manager/secrets/django/secrets.py)
    
    # Step 4: Backup existing database
    backup_database
    
    # Step 5: Initialize volumes for upgrade
    initialize_volumes
    
    # Step 6: Upgrade database
    upgrade_database
    
    # Step 7: Run migration
    run_migration
    migration_result=$?

    # Step 8: Show results
    if [[ $migration_result -eq 0 ]]; then
        log_message "Database upgrade completed successfully"
        echo 
        echo "Old database has been backed up to: scenescape_vol-db-backup"
        echo "                     SQL backup at: ${backup_dir}/scenescape_db_backup_${now}.psql"
        echo
        echo "Upgraded database for Postgres ${pg_new_version} has been created in Docker volumes:"
        echo "  - Database: scenescape_vol-db"
        echo "  - Migrations: scenescape_vol-migrations"
        echo "  - Media: scenescape_vol-media"

        docker run -d --name temp-copy -v scenescape_vol-db:/db alpine:latest sleep 10
        if [ -d "${dbdir}" ]; then
            echo "Removing existing ${dbdir}..."
            rm -rf "${dbdir}"
        fi
        docker rm -f temp-copy
        return 0
    else
        log_message "Database upgrade failed"
        echo
        echo "Database upgrade FAILED. Old database is preserved at: ${backup_dir}"
        return 1
    fi
}

# Execute main function with all arguments
main "$@"
exit $?
